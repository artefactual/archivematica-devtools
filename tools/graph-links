#!/usr/bin/env python2
# -*- coding: utf-8 -*-

# This file is part of Archivematica.
#
# Copyright 2010-2015 Artefactual Systems Inc. <http://artefactual.com>
#
# Archivematica is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Archivematica is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Archivematica.  If not, see <http://www.gnu.org/licenses/>.

import datetime
import sys
import logging
import argparse
import ConfigParser

import pygraphviz as pgv

# Quickest way to access to the MCP database but it assumes that you are
# running this script in the machine where Archivematica was installed.
sys.path.append("/usr/lib/archivematica/archivematicaCommon")
import databaseInterface
databaseInterface.printSQL = False


linkUUIDtoNodeName = {}

excludedNodes = {
    '61c316a6-0a50-4f65-8767-1f44b1eeb6dd': 'default fail procedure for transfers. Too many lines',
    '7d728c39-395f-4892-8193-92f086c0546f': 'default fail procedure for SIPs. Too many lines',
    '333532b9-b7c2-4478-9415-28a3056d58df': 'reject transfer option.',
    '19c94543-14cb-4158-986b-1d2b55723cd8': 'reject sip option',
}

# See http://www.graphviz.org/doc/info/colors.html
COLORS = {
    'node_chain_link': 'black',
    'node_chain_link_start': 'darkgoldenrod',
    'edge_exit_codes_ok': 'black',
    'edge_exit_codes_err': 'red',
    'edge_user_selections': 'green',
    'edge_watched_directories': 'cyan3',
    'edge_load_variable': 'orangered',
    'edge_magic_chain_links': 'brown',
}


# For each MicroServiceChainLink in the MCP Server, the TaskType determines
# what code will be executed for that task.
# See: https://wiki.archivematica.org/MCP/TaskTypes
TASK_TYPES = {

    #
    # General
    #

    # description="one instance"
    'one_instance': '36b2e239-4a57-4aa5-8ebc-7a29139baca6',

    # description="for each file"
    # 'for_each_file': 'a6b1c323-7d36-428e-846a-e7e819423577',

    #
    # User choice
    #

    # description="get user choice to proceed with"
    # '?': '61fb3874-8ef6-49d3-8a2d-3cb66e86a30c',

    # description="get replacement dic from user choice"
    # '?': '9c84b047-9a6d-463f-9836-eafa49743b84',

    # description="Get microservice generated list in stdOut"
    # '?': 'a19bfd9f-9989-4648-9351-013a10b382ed',

    # description="Get user choice from microservice generated list"
    # '?': '01b748fe-2e9d-44e4-ae5d-113f74c9a0ba',

    #
    # Unit variables
    #

    # description="linkTaskManagerSetUnitVariable"
    'unit_var': '6f0b612c-867f-4dfd-8e43-5b35b7f882d7',
    # description="linkTaskManagerUnitVariableLinkPull"
    'unit_var_pull': 'c42184a3-1a7f-4c4d-b380-15d8d97fdd11',

    #
    # Deprecated
    #

    # description="goto magic link"
    # '?': '6fe259c2-459d-4d4b-81a4-1b9daf7ee2e9',

    # description="assign magic link"
    'assign_magic_link': '3590f73d-5eb0-44a0-91a6-5b2db6655889',

}

logging.basicConfig(format='%(message)s', stream=sys.stdout)
logger = logging.getLogger()

config = ConfigParser.ConfigParser()
config.read('/etc/archivematica/MCPClient/archivematicaClientModules')


def get_script_name(name):
    if not isinstance(name, basestring):
        return
    if config.has_option('supportedCommandsSpecial', name):
        return config.get('supportedCommandsSpecial', name)
    if config.has_option('supportedCommands', name):
        return config.get('supportedCommands', name)


def parse_arguments():
    parser = argparse.ArgumentParser()
    parser.add_argument('-f', '--format', choices=['png', 'svg'], default='svg')
    parser.add_argument('-v', '--verbose', action='count')
    args = parser.parse_args()

    return args


def add_edge(G, sourceUUID, destUUID, color='black', label=None):
    if sourceUUID in excludedNodes or destUUID in excludedNodes:
        return
    if sourceUUID is None or destUUID is None:
        return
    if label:
        G.add_edge(linkUUIDtoNodeName[sourceUUID], linkUUIDtoNodeName[destUUID], color=color, label=label)
    else:
        G.add_edge(linkUUIDtoNodeName[sourceUUID], linkUUIDtoNodeName[destUUID], color=color)


def load_chain_links(G):
    """
    Map all the existing job chain links to nodes in the graph.
    Default links are represented with black arrows.
    """
    sql = """
        SELECT
            MicroServiceChainLinks.pk,
            MicroServiceChainLinks.defaultNextChainLink,
            TasksConfigs.description,
            TaskTypes.description,
            TasksConfigs.taskTypePKReference,
            MicroServiceChainLinks.microserviceGroup
        FROM MicroServiceChainLinks
        JOIN TasksConfigs ON currentTask = TasksConfigs.pk
        JOIN TaskTypes ON taskType = TaskTypes.pk;
    """
    links = databaseInterface.queryAllSQL(sql)
    for link in links:
        pk, defaultNextChainLink, description, taskType, pkRef, group = link
        if pk in excludedNodes:
            continue
        sql = """
            SELECT
                execute,
                arguments
            FROM StandardTasksConfigs
            WHERE pk=%s;
        """
        script_name = databaseInterface.queryAllSQL(sql, (pkRef,))
        arguments = None
        if script_name:
            script_name, arguments = script_name[0]
        elif not script_name:
            sql = """
                SELECT
                    variable,
                    variableValue,
                    microServiceChainLink
                FROM TasksConfigsSetUnitVariable
                WHERE pk=%s;
            """
            returned = databaseInterface.queryAllSQL(sql, (pkRef,))
            if returned:
                script_name = '%s, %s' % (returned[0][0], returned[0][1] or returned[0][2])
        # Node info:
        # {MSCL UUID} Name of node
        # (task type description) taskTypePKReference
        # [Name of script] Microservice Group
        nodeName = r"{%s} %s\n(%s) %s\n[%s] %s" % (pk, description, taskType, pkRef, script_name or '', group)
        # Color if start of chain
        border_color = COLORS['node_chain_link']
        sql = """
            SELECT *
            FROM MicroServiceChains
            WHERE startingLink=%s;
        """
        if databaseInterface.queryAllSQL(sql, (pk,)):
            border_color = COLORS['node_chain_link_start']
        full_script_name = get_script_name(script_name)
        tooltip = 'Script name: {}. \n'.format(full_script_name) if full_script_name else 'Full script name not found. '
        tooltip += 'Arguments: {}'.format(arguments) if arguments is not None else 'No arguments'
        G.add_node(nodeName, label=nodeName, id=nodeName, color=border_color, tooltip=tooltip)
        linkUUIDtoNodeName[pk] = nodeName
    for link in links:
        pk = link[0]
        defaultNextChainLink = link[1]
        if defaultNextChainLink is not None:
            add_edge(G, pk, defaultNextChainLink, label='defaultNextChainLink')
    return


def bridgeExitCodes(G):
    """
    Connect tasks based on the exit code. The edges are red if the exit code is
    greater than zero and green otherwise. The exit code is included in the
    label of the edge.
    """
    sql = """
        SELECT
            microServiceChainLink,
            nextMicroServiceChainLink,
            exitCode
        FROM MicroServiceChainLinksExitCodes;
    """
    logger.info('Processing exit codes...')
    rows = databaseInterface.queryAllSQL(sql)
    for row in rows:
        microServiceChainLink, nextMicroServiceChainLink, exit_code = row
        if nextMicroServiceChainLink:
            color = COLORS['edge_exit_codes_ok'] if not exit_code else COLORS['edge_exit_codes_err']
            add_edge(G, microServiceChainLink, nextMicroServiceChainLink, label='EXITCODE={}'.format(exit_code), color=color)


def bridgeUserSelections(G):
    """
    Connect tasks that prompt the user with its corresponding choices. The
    arrows are green and labeled with the choice description.
    """
    logger.info('Processing user choices...')
    sql = """
        SELECT
            MicroServiceChainChoice.choiceAvailableAtLink,
            MicroServiceChains.startingLink,
            MicroServiceChains.description
        FROM MicroServiceChainChoice
        JOIN MicroServiceChains ON (MicroServiceChainChoice.chainAvailable = MicroServiceChains.pk);
    """
    rows = databaseInterface.queryAllSQL(sql)
    for row in rows:
        choiceAvailableAtLink, startingLink, description = row
        if choiceAvailableAtLink and startingLink:
            add_edge(G, choiceAvailableAtLink, startingLink, color=COLORS['edge_user_selections'], label=description)


def bridgeWatchedDirectories(G):
    """
    Connect tasks that represent the end of a chain that moves a package to the
    watched directory of the new chain. The arrors are yellow.

    For example:

        > {61a8de9c-7b25-4f0f-b218-ad4dde261eed} Generate DIP
        > (one instance) ed8c70b7-1456-461c-981b-6b9c84896263
        > [move_v0.0] Prepare DIP

            [â†“] (yellow)

        > {92879a29-45bf-4f0b-ac43-e64474f0f2f9} Upload DIP
        > (get user choice to proceed with) None
        > [] Upload DIP

    Not all the chains are triggered by other tasks, e.g. the following task
    has no successor.

        > {9520386f-bb6d-4fb9-a6b6-5845ef39375f} Approve AIP reingest
        > (get user choice to proceed with) None
        > [] Reingest AIP

    """
    logger.info('Processing watched directories...')
    sql = """
        SELECT
            watchedDirectoryPath,
            startingLink
        FROM WatchedDirectories
        JOIN MicroServiceChains ON (WatchedDirectories.chain = MicroServiceChains.pk);
    """
    rows = databaseInterface.queryAllSQL(sql)
    for row in rows:
        watchedDirectoryPath, startingLink = row
        logger.debug("\nWatched directory [%s] [startingLink=%s]",
            watchedDirectoryPath.replace('%watchDirectoryPath%', ''),
            startingLink)
        count = 0

        sql = """
            SELECT
                MicroServiceChainLinks.pk,
                execute,
                arguments
            FROM StandardTasksConfigs
            JOIN TasksConfigs ON (TasksConfigs.taskTypePKReference = StandardTasksConfigs.pk)
            JOIN MicroServiceChainLinks ON (MicroServiceChainLinks.currentTask = TasksConfigs.pk)
            WHERE
                execute LIKE 'move%%'
                AND taskType = %s
                AND (arguments LIKE %s OR arguments LIKE %s);
        """
        rows2 = databaseInterface.queryAllSQL(sql, (
            TASK_TYPES['one_instance'],
            '%{}%'.format(watchedDirectoryPath.replace('%', '\%')),
            '%{}%'.format(watchedDirectoryPath.replace('%watchDirectoryPath%', '%sharedPath%watchedDirectories/', 1).replace('%', '\%')),
        ))
        for row2 in rows2:
            microServiceChainLink, execute, arguments = row2
            add_edge(G, microServiceChainLink, startingLink, color=COLORS['edge_watched_directories'], label=watchedDirectoryPath)
            logger.debug('  MATCHED SOURCE:\n   -> %s \n   -> %s\n   -> %s', microServiceChainLink, execute, arguments)
            count += 1

        if count == 0:
            logger.info("No sources for watched directory: %s", watchedDirectoryPath)


def bridgeMagicChainLinks(G):
    # find the assignments
    sql = """
        SELECT
            MicroServiceChainLinks.pk,
            TasksConfigsAssignMagicLink.execute
        FROM MicroServiceChainLinks
        JOIN TasksConfigs ON (MicroServiceChainLinks.currentTask = TasksConfigs.pk)
        JOIN TasksConfigsAssignMagicLink ON (TasksConfigsAssignMagicLink.pk = TasksConfigs.taskTypePKReference)
        WHERE TasksConfigs.taskType = %s;
    """
    rows = databaseInterface.queryAllSQL(sql, (TASK_TYPES['assign_magic_link'],))
    for row in rows:
        microServiceChainLink, magicLink = row
        node = G.get_node(linkUUIDtoNodeName[microServiceChainLink])
        # Keep a list of visited nodes to avoid infinite recursion
        visitedNodes = {node: None}
        count = bridgeMagicChainLinksRecursiveAssist(G, node, magicLink, visitedNodes)
        if count == 0:
            logger.info("No loads of set link: %s", node)


def bridgeMagicChainLinksRecursiveAssist(G, node, magicLink, visitedNodes):
    ret = 0
    link = node[1:node.find('}')]
    sql = """
        SELECT MicroServiceChainLinks.pk
        FROM MicroServiceChainLinks
        JOIN TasksConfigs ON (MicroServiceChainLinks.currentTask = TasksConfigs.pk)
        WHERE
            TasksConfigs.taskType = %s
            AND MicroServiceChainLinks.pk = %s;
    """
    rows = databaseInterface.queryAllSQL(sql, (
        TASK_TYPES['assign_magic_link'],
        link,
    ))
    # if it's loading it, set the load and return
    if len(rows):
        add_edge(G, link, magicLink, color=COLORS['edge_magic_chain_links'])
        return 1
    else:
        for neigh in G.neighbors_iter(node):
            if neigh in visitedNodes:
                continue
            visitedNodes[neigh] = None
            ret += bridgeMagicChainLinksRecursiveAssist(G, neigh, magicLink, visitedNodes)
    return ret


def bridgeLoadVariable(G):
    sql = """
        SELECT
            MicroServiceChainLinks.pk,
            TasksConfigsUnitVariableLinkPull.variable,
            TasksConfigsUnitVariableLinkPull.defaultMicroServiceChainLink
        FROM MicroServiceChainLinks
        JOIN TasksConfigs ON (MicroServiceChainLinks.currentTask = TasksConfigs.pk)
        JOIN TasksConfigsUnitVariableLinkPull ON (TasksConfigsUnitVariableLinkPull.pk = TasksConfigs.taskTypePKReference)
        WHERE TasksConfigs.taskType = %s;
    """
    rows = databaseInterface.queryAllSQL(sql, (TASK_TYPES['unit_var_pull'],))
    for row in rows:
        count = 0
        microServiceChainLink, variable, defaultMicroServiceChainLink = row
        sql = """
            SELECT
                MicroServiceChainLinks.pk,
                TasksConfigsSetUnitVariable.variable,
                TasksConfigsSetUnitVariable.microServiceChainLink
            FROM MicroServiceChainLinks
            JOIN TasksConfigs ON MicroServiceChainLinks.currentTask = TasksConfigs.pk
            JOIN TasksConfigsSetUnitVariable ON TasksConfigsSetUnitVariable.pk = TasksConfigs.taskTypePKReference
            WHERE
                TasksConfigs.taskType = %s
                AND TasksConfigsSetUnitVariable.variable = %s;
        """
        rows2 = databaseInterface.queryAllSQL(sql, (
            TASK_TYPES['unit_var'],
            variable,
        ))
        for row2 in rows2:
            microServiceChainLink2, variable, microServiceChainLinkDest = row2
            add_edge(G, microServiceChainLink, microServiceChainLinkDest, color=COLORS['edge_load_variable'], label=variable)
            count += 1
        if defaultMicroServiceChainLink:
            add_edge(G, microServiceChainLink, defaultMicroServiceChainLink, color=COLORS['edge_load_variable'], label='default MSCL')
        if count == 0:
            logger.info("No bridge variable set for %s", linkUUIDtoNodeName[microServiceChainLink])


def main():
    args = parse_arguments()

    if args.verbose == 1:
        logger.setLevel(logging.INFO)
    elif args.verbose > 1:
        logger.setLevel(logging.DEBUG)

    G = pgv.AGraph(strict=True, directed=True)

    # Nodes
    load_chain_links(G)

    # Edges
    bridgeExitCodes(G)
    bridgeUserSelections(G)
    bridgeWatchedDirectories(G)
    bridgeLoadVariable(G)
    bridgeMagicChainLinks(G)

    # HACK? Represent the connection of the transfer and the ingest chains.
    #
    #     > {3e75f0fa-2a2b-4813-ba1a-b16b4be4cac5} Move to SIP creation directory for completed transfers
    #     > (one instance) ac562701-7672-4e1d-a318-b986b7c9007c
    #     > [moveTransfer_v0.0] Create SIP from Transfer
    #
    #         [â†“] (black)
    #
    #     > {db6d3830-9eb4-4996-8f3a-18f4f998e07f} Set file permissions
    #     > (one instance) 6157fe87-26ff-49da-9899-d9036b21c4b0
    #     > [setDirectoryPermissionsForAppraisal_v0.0] Verify SIP compliance
    #
    add_edge(G, '3e75f0fa-2a2b-4813-ba1a-b16b4be4cac5', 'db6d3830-9eb4-4996-8f3a-18f4f998e07f', label='Transfer -> Ingest (manual)')

    G.layout(prog='dot')

    date = datetime.date.today()
    filename = 'chainlinks-{}.{}'.format(date, args.format)
    draw_args = "-Goverlap=prism "
    if args.verbose > 2:
        draw_args += "-v "

    ret = 1
    try:
        G.draw(filename, args=draw_args)
        ret = 0
    except:
        logger.exception('G.draw() failed! See exception details below...\n\n')

    return ret


if __name__ == '__main__':
    sys.exit(main())
