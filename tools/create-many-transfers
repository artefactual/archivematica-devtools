#!/usr/bin/env python2
# -*- coding: utf-8 -*-

# This file is part of the Archivematica development tools.
#
# Copyright 2010-2016 Artefactual Systems Inc. <http://artefactual.com>
#
# Archivematica is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Archivematica is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Archivematica.  If not, see <http://www.gnu.org/licenses/>.

from __future__ import print_function
import argparse
import errno
import os
import shutil
import sys
import time

import django

sys.path.append('/usr/share/archivematica/dashboard')
os.environ['DJANGO_SETTINGS_MODULE'] = 'settings.common'
from contrib.mcp.client import MCPClient

django.setup()
from main.models import Transfer, Job


def copy_anything(src, dst):
    # http://stackoverflow.com/questions/1994488/copy-file-or-directory-in-python
    try:
        shutil.copytree(src, dst)
    except OSError as exc: # python >2.5
        if exc.errno == errno.ENOTDIR:
            shutil.copy(src, dst)
        else:
            raise


def make_filepath_unique(filepath, original=None, attempt=0):
    """ Add up to 3 _ at the end of a transfer to make the name unique. """
    if original is None:
        original = filepath
    attempt = attempt + 1
    if os.path.exists(filepath):
        return make_filepath_unique(original + '_' + str(attempt), original, attempt)
    return filepath


def make_transfer(path, transfer_name):
    transfer_path = os.path.join('/', 'var', 'archivematica', 'sharedDirectory', 'watchedDirectories', 'activeTransfers', 'standardTransfer', transfer_name)
    transfer_path = make_filepath_unique(transfer_path)
    print('Creating transfer at', transfer_path)
    try:
        os.mkdir(transfer_path)
        for entry in os.listdir(path):
            entry_path = os.path.join(path, entry)
            transfer_entry_path = os.path.join(transfer_path, entry)
            copy_anything(entry_path, transfer_entry_path)
    except OSError:
        print('Error copying from', entry_path, 'to', transfer_entry_path, '. (', sys.exc_info()[0], ')')
    return os.path.basename(transfer_path)


def approve_transfer(transfer_name):
    # TODO replace this with something like automation_tools.transfer.approve_transfer
    approve_chain_uuid = '6953950b-c101-4f4c-a0c3-0cd0684afe5e'
    user_id = 1
    path = os.path.join('activeTransfers', 'standardTransfer', transfer_name)+'/'
    transfer = Transfer.objects.get(currentlocation__endswith=path)
    transfer_name = transfer.currentlocation.split('/')[-2]
    print('Approving transfer:', transfer_name)
    job_uuid = Job.objects.get(jobtype='Approve standard transfer', sipuuid=transfer.uuid).jobuuid
    client = MCPClient()
    client.execute(job_uuid, approve_chain_uuid, user_id)


def make_transfers(num_transfers, start_number, path, transfer_name):
    names = ['{name}_{number}'.format(name=transfer_name, number=i) for i in range(start_number, start_number+num_transfers)]
    # Start transfers, updating stored name
    names = [make_transfer(path, name) for name in names]
    print("Waiting 15 seconds for Archivematica to process transfers...")
    time.sleep(15)
    for name in names:
        approve_transfer(name)

if __name__ == '__main__':
    desc = """Create many many transfers for scalability testing.  Creates NUM_TRANSFERS transfers in Archivematica, named NAME_<number>.  <number> will start at START_NUMBER and end at START_NUMBER+NUM_TRANSFERS.
    """
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument('path', type=str, help='Path to directory to use for all the transfers')
    parser.add_argument('-n', '--num-transfers', default=1, type=int, help='Number of transfers to create')
    parser.add_argument('--start-number', default=0, type=int, help='Number to start indexing the transfers from')
    parser.add_argument('--name', type=str, default='test', help='Name of all the transfers.')
    args = parser.parse_args()
    make_transfers(args.num_transfers, args.start_number, args.path, args.name)
